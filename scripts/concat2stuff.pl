
=head1 NAME

concat2stuff.pl - Convert concatenated WikiSource code into other files.

=head1 SYNOPSIS

    perl concat2stuff.pl dwc  < concat_input.txt > darwincore.txt

=head1 COMMAND LINE

The command line is in the format:

    perl concat2stuff.pl <output format>

A "concat" file (as generated by L<concat.pl>) is read from STDIN; the output
file will be written out to STDOUT.

Two output formats are currently supported:

=over

=item dwc

Outputs the concatenated file as a CSV file. Some of the CSV fields are 
drawn directly from DarwinCore; others are used to keep the information
in these files for later processing.

=item trail

Extracts a list of locations mentioned. Apart from locations mentioned
in passing (e.g. "This place reminded me of {{place|Wyoming}} ..."),
this should be a record of every place where the author visited.

=back

=cut

use strict;
use warnings;

use 5.0100;

use Text::CSV;
use POSIX;

binmode(STDOUT, ":utf8");
binmode(STDIN, ":utf8");

my @entries;

my $current_entry;
while(<STDIN>) {
    if(/^(.*)\s*{{new-entry}}\s*(.*)$/i) {
        # Append the string before the new entry to the current entry.
        $current_entry .= $1; 

        push @entries, $current_entry;

        # Set up the next current entry with the rest of the last line.
        $current_entry = $2;
    } else {
        $current_entry .= $_;
    }
}
if($current_entry ne "") {
    push @entries, $current_entry;
}

say STDERR "$#entries entries loaded.";

my $method = lc $ARGV[0];
$method = \&dwc if $method eq 'dwc';
$method = \&trail if $method eq 'trail';
die "Invalid method: $method"
    unless ref($method) eq 'CODE';

my $csv = Text::CSV->new({eol => "\n", binary => 1});
my $header = $method->();
$csv->print(\*STDOUT, $header);

my $entry_count = 0;
foreach my $entry (@entries) {
    $entry_count++;

    # TODO: Split by {{...}} references, then process all of them.   
    # We can't just download them, because relative order is really important here.
    while($entry =~ /{{(#?[\w\s]+\|.*?)}}/ig) {
        my $tag = $1;

        my $pos = pos($entry);

        my $CONTEXT_SIZE = 250;
        my $start = $pos - int($CONTEXT_SIZE/2);
        $start = 0 if $start < 0;
        # say STDERR "pos = $pos, start = $start";

        my $context = substr($entry, $start, $CONTEXT_SIZE);
        $context = "" unless ($tag =~ /^taxon/i);
        # say STDERR "substr($start, $CONTEXT_SIZE) = '$context'";
        my $result = $method->($tag, $entry, $entry_count, $context);
        if(defined $result) {
            $csv->print(\*STDOUT, $result);
        }
    }
}

# Some processing methods.
sub dwc {
    my ($tag, $entry, $entry_count, $context) = @_;

    return [
        "catalogNumber", 
        "dc:modified",
        "basisOfRecord",
        "institutionCode",
        "collectionCode",
        "associatedMedia",
        "fieldNotes",
        "scientificName",
        "vernacularName",
        "ScrapedName",
        "AnnotatorName",
        "VerbatimDate",
        "identifiedBy",
        "dateIdentified",
        "associatedReferences",
        "dataGeneralizations",
        "identificationRemarks",
        "occurenceRemarks",
        "country",
        "countryCode",
        "stateProvince",
        "county",
        "locality",
        "verbatimLocality",
        "AnnotatorLocality",
        "ScrapeGoatField",
        "decimal latitude",
        "decimal longitude",
        "geodeticDatum",
        "coordinateUncertaintyInMeters",
        "georeferencedBy",
        "georeferencedDate",
        "Kingdom",
        "Phylum",
        "Class",
        "Order",
        "Family",
        "Genus",
        "Species",
        "EventDate",
        "Day",
        "Month",
        "Year"
        ]
        if not defined $tag;

    state $current_place;
    state $current_place_str;
    state $current_date;
    state $current_date_str;
    state $current_page_uri;
    state $current_state;
    state %page_count;

    if($tag =~ /^place\|(.*)/i) {
        $current_place = $1;
        $current_place_str = $1;

        if($current_place =~ /(.*)\|(.*)/) {
            $current_place = $1;
            $current_place_str = $2;
        }

        if($current_place_str =~ /^(\w+), (\w+)$/) {
            $current_state = $2;
        }
    }

    if($tag =~ /^dated\|(.*)$/) {
        if($tag =~ /^dated\|(\d+)-(\d+)-(\d+)$/i) {
            $current_date = "$1-$2-$3";
            $current_date_str = "$1-$2-$3";
        } elsif($tag =~ /^dated\|(\d+)-(\d+)-(\d+)\|(.*)$/i) {
            $current_date = "$1-$2-$3";
            $current_date_str = $4;
        } else {
            die "Could not process date: $tag";
        }
    }

    if($tag =~ /^#from.*\|uri=(.*)\|?/i) {
        $current_page_uri = $1;
    }

    if($tag =~ /^taxon\|(.*)$/i) {
        my $taxon_name = $1;
        my $taxon_str = $1;

        if($taxon_name =~ /(.*)\|(.*)/) {
            $taxon_name = $1;
            $taxon_str = $2;
        }

        # What we got: return [$entry_count, $taxon_name, $current_date, $current_place, $current_page_uri, $entry];
        my ($notebook_number) =     ($current_page_uri =~ /Page:Field_Notes_of_Junius_Henderson,_Notebook_(\d+)\..{1,4}\//);
        die "No notebook number discernable in URI '$current_page_uri'" unless defined $notebook_number;

        my ($page_number) =         ($current_page_uri =~ /Page:Field_Notes_of_Junius_Henderson,_Notebook_\d+\..{1,4}\/(\d+)\?/);
        die "No page number discernable in URI '$current_page_uri'" unless defined $page_number;

        if(not exists $page_count{$page_number}) {
            $page_count{$page_number} = "A";
        } else {
            $page_count{$page_number}++;
        }

=head1 DARWIN CORE OUTPUT (dwc)

=head2 Field names

The following fields are written out for a Darwin Core file (i.e. when output format is set to "dwc").

See https://docs.google.com/spreadsheet/ccc?key=0AvsrI9Pi83gYdGpnLUZadG56ejJuQmZMSHFiX1hFTkE#gid=0 for an example.

=over

=item catalogNumber

The string C<JHFN(1)-(2)-(3)> where:

=over

=item (1)

is the notebook number (from 1 to 13)

=item (2)

is the page number within that notebook, and

=item (3)

is an alphabet denoting the entry within that page. The first entry in the page will be 'A',
the second will be 'B', and so on. Once the algorithm reaches 'Z', it will continue with
entry 'AA', then 'AB', and so on.

=back

=item dc:modified

The date at which this file was modified, i.e. the current local date (in YYYY-MM-DD format).

=item basisOfRecord

Currently set to C<HumanObservation>.

=item institutionCode

Currently set to C<UCM>.

=item collectionCode

Currently set to C<HendersonNotes>.

=item associatedMedia

The permanent URL of this page, e.g. http://en.wikisource.org/wiki/Page:Field_Notes_of_Junius_Henderson,_Notebook_1.djvu/114?oldid=3581927

Note that the only really important part of the URL is the C<oldid=...> bit at the end; whatever you set
the page title to be, Mediawiki will return the correct page if the C<oldid> is correct.

=item fieldNotes

The permanent URL of the Junius Henderson field notebook transcriptions, currently
set to C<http://en.wikisource.org/wiki/Field_Notes_of_Junius_Henderson>.

=item scientificName

Currently left blank for later processing.

=item vernacularName

Currently left blank for later processing.

=item ScrapedName

The taxon name, as entered by the original author.

=item AnnotatorName

The taxon name, as entered by the annotator. Where the annotator entered a single name
(i.e. C<{{taxon|Inoceramus barabini}}> or C<{{taxon|cowbird}}>), this value is used for
both the ScrapedName and AnnotatorName fields.

=item VerbatimDate

The date for this entry, as entered by the author.

=item identifiedBy

Currently set to C<Junius Henderson>.

=item dateIdentified

The date for this entry, as entered by the annotator. This is only
accepted if the date was entered in a YYYY-MM-DD format.

=item associatedReferences

=item dataGeneralizations

=item identificationRemarks

=item occurenceRemarks

All currently blank.

=item country

Currently C<United States of America>.

=item countryCode

Currently C<US>.

=item stateProvince

This script attempts to guess a state from the location (i.e. "Boulder, CO" -> "CO").
Note that this is maintained until it is changed, so if the script does not pick up
a change in state ("Boulder, CO" to "San Francisco Calif", for instance) then the
previous state (in this case, "CO") will continue to be filled in on subsequent entries
(in this case, those from SF).

=item county

=item locality

Currently blank.

=item verbatimLocality

The current place, as written by the author.

=item AnnotatorLocality

The current place, as written by the annotator. We encourage annotators
to use standardized place names ("Bould. CO" -> "Boulder, Colorado").

=item ScrapeGoatField

A field deliberately left blank for later corrections to be logged.

=item decimal latitude

=item decimal longitude

=item geodeticDatum

=item coordinateUncertaintyInMeters

=item georeferencedBy

=item georeferencedDate

Left blank for georeferencing information.

=item Kingdom

=item Phylum

=item Class

=item Order

=item Family

=item Genus

=item Species

Left blank for taxonomic referencing information.

=item EventDate

=item Day

=item Month

=item Year

Left blank for date information.

=cut

        return [
            # "catalogNumber", 
            "JHFN$notebook_number-$page_number-" . $page_count{$page_number}, 

            # "dc:modified",
            "'" . POSIX::strftime('%Y-%m-%d', localtime),

            # "basisOfRecord",
            "HumanObservation",

            # "institutionCode",
            "UCM",

            # "collectionCode",
            "HendersonNotes",

            # "associatedMedia",
            $current_page_uri,

            # "fieldNotes",
            "http://en.wikisource.org/wiki/Field_Notes_of_Junius_Henderson",
    
            # "scientificName",
            "", #$taxon_name,

            # "vernacularName",
            "", #$taxon_str,

            # ScrapedName
            $taxon_str,

            # AnnotatorName
            $taxon_name,

            # "VerbatimDate",
            "'" . $current_date_str,

            # "identifiedBy",
            "Junius Henderson",

            # "dateIdentified",
            "'" . $current_date,

            # "associatedReferences",
            "",

            # "dataGeneralizations",
            $context, # "", # $entry,

            # "identificationRemarks",
            "",

            # "occurenceRemarks",
            "", #$entry,

            # "country",
            "United States of America",

            # "countryCode",
            "US",

            # "stateProvince",
            $current_state, 
        
            # "county",
            "",
            
            # "locality",
            "",

            # "verbatimLocality",
            $current_place_str,

            # "AnnotatorLocality",
            $current_place,

            # "ScrapeGoatField",
            "",
            
            # "decimal latitude",
            "",

            # "decimal longitude",
            "",

            # "geodeticDatum",
            "",

            # "coordinateUncertaintyInMeters",
            "",

            # "georeferencedBy",
            "",

            # "georeferencedDate",
            "",

            # "Kingdom",
            "",

            # "Phylum",
            "",

            # "Class",
            "",

            # "Order",
            "",

            # "Family",
            "",

            # "Genus",
            "",

            # "Species",
            "",

            # "EventDate",
            "",

            # "Day",
            "",

            # "Month",
            "",

            # "Year"
            ""
        ];
    }

    return undef;
}

sub trail { 
    my ($tag, $entry, $entry_count, $context) = @_;

    return ["EntryNo", "Date", "Place", "URI", "Entry"]
        if not defined $tag;

    state $current_place;
    state $current_date;
    state $current_page_uri;

    my $new_tag = 0;
    if($tag =~ /^place\|(.*?)\|.*/i) {
        $current_place = $1;
        $new_tag = 1;
    }

    if($tag =~ /^dated\|(\d+)-(\d+)-(\d+).*/i) {
        $current_date = "$1-$2-$3";
        $new_tag = 1;
    }

    if($tag =~ /^#from.*\|uri=(.*)\|?/i) {
        $current_page_uri = $1;
    }

    if($new_tag and defined($current_date) and defined($current_place)) {
        return [$entry_count, $current_date, $current_place, $current_page_uri, "entry"];
    }

    return undef;
}
